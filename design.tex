% !TEX root = ./paper.tex
\subsection{The Secure Control Channel}\label{sec:extending}

\tls 1.3~\cite{rfc8446} has been designed with careful consideration for
potential extensions and to prevent middlebox interference. A \tcpls client
indicates its willingness to use \tcpls with a transport parameter in the
\textsc{ClientHello} message. Upon reception of this parameter, the server
replies with a \textsc{ServerHello} messages. It can opportunistically add
lightweight \tcpls data and \tcp options as \textsc{EncryptedExtensions}. Any
extension sent with the \textsc{ServerHello} message is encrypted with the
handshake key, and is not part of the context used to derive the eventual
application key. If the client does not support some extension, it echoes back
an alert with the value of the option it does not recognize, letting the connection
continues.

A reasonable approach to design extensibility mechanisms in today's Internet
is to avoid leaking any information that could help an on-path attacker
recognize specific users or applications. Indeed, censorship~\cite{Morshed2017a,
Gosain2017a,Chai2019a} can be easily implemented when protocol messages can be
distinguished. Avoiding trivial opportunities to implement censorship should
become the bare minimum in designing a new protocol. \tcpls's control protocol
considers those problems by avoiding plaintext extensions data in the
\textsc{ClientHello} as most as possible.

Once the secure handshake has succeeded, the hosts can exchange \tls records.
To prevent middlebox interference, the \tls 1.3 Record Protocol ensures that any
new message appears as an \textsc{AppData} message type. \tls stores the true
content type (TType) at the end of the encrypted payload. \tcpls uses this
feature of \tls 1.3 to encode the control messages that are sent over the secure
channel as new \tls record types.

\subsection{The \tcpls Streams}\label{sec:datastreams}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The classical solution to support streams in a transport protocol is to assign
an identifier to each stream and send the data from stream $x$ as a tuple
$x,seq,data$ where $seq$ is a sequence number. This is the solution chosen by
\sctp~\cite{rfc4960} and \quic~\cite{draft-ietf-quic-transport}. \tcpls relies
on cryptographic properties to support several streams.

\paragraph*{Cryptographic Details and Tricks} In \tcpls, each stream has its own
cryptographic context. All streams use the same key but derive a specific
Initial Vector (IV - also called cryptographic nonce) such that nonce-misuse
cannot happen. Furthermore, \tcpls derives the IV such that the record sequence
numbers can securely start at $0$ within each stream.

\tcpls uses only one application-level key for $N$ streams, for each direction.
We selected this approach to avoid security degradation with the usage of
multiple keys (by a factor $k$ with $k$ keys)~\cite{chatterjee2011another}.

To enable all stream sequence numbers to start at 0, we rely on some properties
of the Authenticated Encryption with Associated Data (AEAD) schemes used by \tls
1.3. To preserve AEAD security, the AEAD nonce used by \tcpls must be of unique
use when encrypting and decrypting a record. The initial nonce must also be
unpredictable for an adversary observing the handshake. \tcpls derives it from
the \tls handshake session secret in a similar fashion to the \tls
keys~\cite{rfc8446}. The nonce size ranges from $96$ bits to $128$ bits
depending on the underlying cipher used. In all cases, for a nonce of size $N$
bits, \tls computes the cryptographic nonce by concatenating the $N-64$ leftmost
bits with the 64 lower bits XORed with the record's implicit sequence number
encoded in 64 bits. XORing the lower 64 bits provides more unpredictability to
the nonce when the same plaintext is encrypted multiple times with the same
key~\cite{bellare2016multi,hoang2018multi}. This design implies that we give to
the underlying cipher the 32 upper bits untouched. The resulting value is then
incremented at most 1,024 times starting from the leftmost bits to encrypt a
\tls record of maximum size (16,384 bytes,
i.e, 1,024 $\times$ 128 bits, with 128 bits the size of the minimum AEAD block
size). We thus observe that 7 bits among those 32 bits are untouchable, leading
to at least 25 bits that are available to encode a unique stream number. By
encoding such a unique number in this part of the cryptographic nonce, we enable
each stream to start its sequence number at 0 while encrypting its records with
the same key. This observation means that we can create independent
cryptographic contexts based on a cryptographic nonce's tweak. This implies
that stream records can be encrypted and decrypted independently of each other,
with the same key value. This technique maintains AEAD's core assumption
(uniqueness of nonce), which means that state of art AEAD's security proof
starting from that assumption applies to our
design~\cite{chatterjee2011another} and guarantees the security of our scheme.

\paragraph*{Carrying Multiple Streams over the Same Transport}
Thanks to those separate cryptographic contexts, \tcpls can perform concurrent
encryption and decryption between streams while maintaining decryption
correctness and security, and potentially also use this capability to process
different streams over different CPU cores.
Finally, when different streams are carried
over the same \tcp connection, \tcpls does not explicitely know which stream
a received record belongs to. To retrieve this information,
we also
leverage the AEAD cipher and check the incoming record's authentication tag
until we find the stream that properly verifies this tag. This operation is
lightweight: it does not require full decryption of the record because the AEAD
ciphers used by \tls 1.3 do Encrypt then MAC (and MAC then Decrypt).
Looking for the right stream that succeeds the tag verification needs to be
performed once each time the application writes to another stream over the same
\tcp connection.

Note that, security-wise, each failed decryption is considered a
forgery attempt. However, we have large limits on the confidentiality and
integrity with all AEAD ciphers~\cite{luykx2015limits, aeadlimits} before a
successful forgery may be considered as a non-negligible probability. For
example, in the case of ChaCha20+Poly1305, an adversary making $2^{60}$ forgery
attempts succeeds with probability $2^{-33}$.

\subsection{Connection Management}\label{sec:multipath}

\tcpls includes a Connection Manager (CM) that controls the underlying \tcp
connections.
The CM is fully configurable and exposed to applications through the \tcpls API.
\tcpls enables the client or the server to associate new \tcp connections to an
existing \tcpls session. This is similar to \mptcp's path
managers~\cite{raiciu2012hard,hesmans2015smapp,hesmans2016enhanced},
but with some differences. First, \tcpls does not suffer from the same
security limitations as \mptcp. Second, \tcpls supports several modes
of multipathing including connection failover and bandwidth aggregation.

\begin{figure}[!t]
  \centering
  \begin{tikzpicture}
    \colorlet{lightgray}{black!20}
    \tikzstyle{arrow} = [thick,->,>=stealth]
    \tikzset{state/.style={rectangle, dashed, draw, fill=white} }
    \node[black, fill=white] at (0,10) {Client};
    \node[black, fill=white] at (6,10) {Server};
    \node[red, fill=white] at (5.6,9.5) {@v4};
    \node[blue, fill=white] at (6.4,9.5) {@v6};
    \node[red, fill=white] at (-0.4,9.5) {@v4};
    \node[blue, fill=white] at (0.5,9.5) {@v6};
    \draw[red, very thick,->] (-0.4,9.5) -- (-0.4,6.5);
    \draw[blue, very thick,->] (0.5,9.5) -- (0.5,6.5);
    \draw[red, very thick,->] (5.6,9.5) -- (5.6,6.5);
    \draw[blue, very thick,->] (6.4,9.5) -- (6.4,6.5);
   \draw[black, thick, ->] (-0.4,9) -- (5.6,9) node [midway, fill=white, above,
   text width=3cm] {\textsc{ClientHello}+\emph{\tcpls}};
   \draw[black, thick, <-] (-0.4,8.7) -- (5.6,8.7) node [pos=0.5, fill=white, below, text width=4.5cm] {\textsc{ServerHello}+\emph{\tcpls+SESSID($\alpha$)+COOKIE($\beta_1,\beta_2$)}};
   \draw[black, thick, ->] (0.5,7) -- (6.0,7) node [pos=0.4, %fill=white, above,
   text width=4cm] {\textsc{ClientHello}+\join(SESSID($\alpha$),COOKIE($\beta_1$))};
  \end{tikzpicture}
  \caption{\tcpls supports the attachment of additional \tcp
    connections to a \tcpls session. The $SESSID$ and $COOKIE$ are encrypted with the
    handshake key.}
  \label{fig:join-example}
\end{figure}

\paragraph*{1) Better Security Than \mptcp} A \mptcp connection gathers several
underlying connections that are called subflows. To ``secure'' the attachment of
additional subflows, \mptcp hosts exchange short keys in plaintext inside \tcp
options during the \tcp handshake~\cite{rfc6824, rfc8684}. These keys are then
used later to authenticate the attachment of subflows. An
attacker that has observed the initial handshake can attach any subflow to an
existing \mptcp connection~\cite{rfc6181}. \tcpls leverages its secure channel to solves this \texttt{``connection join''} problem in a much more secure manner. Consider a client connecting to a dual-stack server (Fig.~\ref{fig:join-example} depicts the \tls messages exchanged in such a scenario). The client sends a \textsc{ClientHello} containing the \tcpls extension to negotiate \tcpls. The server replies with a \textsc{ServerHello} with three types of encrypted extensions. First, the server announces its IPv4 and IPv6 addresses. Second, it associates one identifier to the \tcpls session (SESSID($\alpha$) in Fig.~\ref{fig:join-example}). This identifier uniquely identifies the \tcpls session on the server. Third, the server provides a list of \tcpls session cookies (COOKIE($\beta_1,\beta_2$) on Fig.~\ref{fig:join-example}). Each of these session cookies enables the client to attach one additional \tcp connection to the \tcpls session. By sending $n$ cookies, the server indicates that it currently accepts the attachment of only $n$ \tcp connections to this session. This prevents resources exhaustion attacks that are difficult to counter with \mptcp. The server can send additional cookies later and update its list of addresses. \tcpls is symmetrical and the client can also announce its addresses and send cookies.

To attach a new connection, e.g., using the server's IPv6 address, the client
sends a \textsc{ClientHello} message containing the session identifier
(SESSID($\alpha$) on Fig.~\ref{fig:join-example}) and one of the server's cookies (COOKIE($\beta_1$) on Fig.~\ref{fig:join-example}). The server checks the validity of the cookie and then uses the session identifier to attach the new \tcp connection to the right \tcpls session. The session identifier and cookie play that same role as \mptcp's token. From a security viewpoint, \tcpls'
session cookie is longer than \mptcp's token. Furthermore it is sent encrypted in the initial \textsc{ServerHello} message, and can only be used once (i.e., when the server receives a valid cookie, it accepts the connection, attaches it to the right \tcpls session, and discards the cookie).

upon network outage, \tcpls can recover the session over another \tcp
connection. When the failover mode is enabled, \tcpls sends stream-level record
acknowledgements announcing to the peer the records that have been received
over each stream. Upon network outage, \tcpls \textbf{\textit{moves}} the
active streams out of the broken \tcp connection to an active one. Furthermore,
the unacknowledged data records that were sent over a failed \tcp connection are
\textbf{\textit{sent again}} on a functional \tcp connection.
\tcpls' Failover mode is optionnal. It needs to be activated by both peers or
negotiated throught the Secure Control Channel.
We discuss in Sec.~\ref{sec:perf} measurements quantifying the
performance impact of adding \tcpls record level acknowledgements.

Second, \tcpls also supports the \textit{Application-level Connection Migration}
mode. Essentialy, it means that \tcpls provides a simple API that enables an
application to migrate when it wishes to do so (e.g., a smartphone could migrate
from LTE to Wi-Fi when the Wi-Fi appears healthy, a client using privacy
compliant IPv6 addresses~\cite{rfc4941} could restart the underlying \tcp
connection after the expiration of a temporary address, \ldots). The semantic of
the application-level connection migration is built from attaching and closing
streams in the multipath bandwidth aggregation mode. The host that wishes to
carry such a migration first creates a new \tcp connection and joins the \tcpls
session over this connection. Then, it attaches new streams to the new
connection by sending one \textsc{Stream\_Attach} message per stream that needs
to be migrated. At that moment, the client and the server have potentially
multiple streams opened over the two network paths. Then, after having attached
all its streams to the new path, the migrating host sends a
\textsc{Stream\_Close} message over the old \tcp connection for all old streams.
At this point, the migrating host cannot send new stream data anymore over the
old connection. Once the remote host has received a \textsc{Stream\_Close}
message over the old \tcp connection, it knows that the connection is not
available anymore, and needs to find a (potentially fresh) connection to send
its data (i.e., the ones that just opened over the new path). It first sends a
\textsc{Stream\_Close\_Ack} message for each received \textsc{Stream\_Close}.
The migrating host can close the old connection upon reception of the last
\textsc{Stream\_Close\_Ack}, indicating that no more data would be received over
this connection. Note that since these messages are \tls records, they are sent
reliably by the underlying \tcp connection.

This second type of migration does not require application-level
acknowledgements, but it cannot survive from the failure of one of the
underlying connections. During such a migration, data is sent over two
connections, which brings us to explain how multipath is designed

\paragraph*{3) Different Multipath Modes}
Like \mptcp \cite{raiciu2012hard,rfc6824} or Multipath QUIC \cite{de2017multipath,draft-liu-multipath-quic-02}, \tcpls supports an aggregation mode that maps data over two or more \tcp connections. On multihomed hosts, this can increase the total throughput of a \tcpls session by spreading the data over different network interfaces. In this case, one or more data streams are mapped to two or more underlying \tcp connections and \tcpls schedules different records over different connections.

In addition, \tcpls allows the application to attach its streams to the
underlying \tcp connections in a non-aggrega-ted bandwidth mode. This is a choice left to the application using the API. It has several advantages and drawbacks compared to the aggregation mode. For example, the aggregation mode is simple to use and can potentially saturate the available network paths but can lead to Head-Of-Line (HOL) blocking, since records sent over different \tcp connections need to be eventually re-ordered. The aggregation mode is also more CPU costly, since a zero-copy codepath is technically possible only when the records arrive in order. In the non-aggregated multipath mode, the application needs to take care to fully send an application-level object over the same stream, since the ordering is only guaranteed per-stream in this mode. However, our \tcpls implementation guarantees that this mode will benefit from zero-copy of the decrypted application data, which makes this mode potentially quite interesting for application protocols such as HTTP that need to fetch multiple application objects at the same time.

\subsection{Improving \tcp's Extensibility}

%\label{sec:tcpoptions}
%% Discussing the lack of extensibility of TLS 1.3;
%\begin{figure}[!t]
  %\begin{bytefield}[bitwidth=0.47em]{40}
    %%\bitheader[lsb=0,bitformatting={\tiny\rotatebox[origin=B]{90}}]{0,7,8,15,16,23,24,31,32,39} \\
    %\bitheader[lsb=0,bitformatting={\tiny}]{0,7,15,23,31,39} \\
    %\begin{rightwordgroup}{Header}
      %\bitbox{8}{Type} & \bitbox{16}{Version} & \bitbox{16}{Length}
    %\end{rightwordgroup}\\
    %\begin{rightwordgroup}{Payload}
      %\bitbox{16}{Option Type} & \bitbox{16}{User Timeout} & \bitbox{8}{TType}
     %%&\wordbox[lrb]{1}{Padding... (to match the AEAD block size)}
    %\end{rightwordgroup}\\
  %\end{bytefield}
  %\caption{All \tcpls records have the same type but differ in their encrypted TType. This sample record contains the User Timeout \tcp option.}
  %\label{fig:ex_record}
%\end{figure}

\tcp~\cite{rfc793} limits the size of the entire \tcp header (including options) to 64 bytes. Unfortunately, the \tcp designers did not foresee that so many \tcp extensions would be standardized. Today, the \tcp header size becomes a constraint.
%For example, it severely limits the number of gaps that
%can be covered by selective acknowledgments.
This gets worse with extensions such as \mptcp~\cite{rfc6824} that consume more space in the \tcp header. The IETF has discussed this problem for several years, but the latest attempt to solve it~\cite{draft-ietf-tcpm-tcp-edo-10} has not yet been implemented by major \tcp stacks.

\tcpls provides more space for \tcp options. First, with \tcpls, \tcp
options can be negotiated during the \tls handshake. Since the \tls messages are
included in the \tcp payload, there is more space to carry them. Another
advantage of this approach is that the \tcp options are secured by \tls. This
implies that they cannot be modified by middleboxes. This could be an advantage,
but could also prevent \tcpls from correctly working through some types of
transparent \tcp proxies.

Second, \tcpls can also carry \tcp options inside \tls records. \tcpls includes
one record type to carry \tcp options. This new type of records can be used to carry TCP options that need to be exchanged reliably such as the \tcp User Timeout option \cite{rfc5482} or \mptcp's \texttt{ADD\_ADDR} and \texttt{REMOVE\_ADDR} option or experimental \tcp options \cite{rfc6994}.

\subsection{Secure Connection Closing}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tcpls's semantic offers a secure stream abstraction to the application.
Streams can be attached to and closed from what we call a \texttt{transportid}
(the application does not have any knowledge of the \tcp interface). When a
stream gets attached for the first time to a \tcp connection, this connection
becomes active. The only way to gracefully close a \tcp connection is by securely closing all streams attached to it, then \tcpls gracefully closes the \tcp connection. That is, if \tcpls receives a \rst or a \fin over an active \tcp connection, it tries to re-establish a \tcp connection. If failover is enabled, \tcpls would try another network path first. Otherwise, a connection over the same IP source and destination is reestablished and the streams are moved to this new \tcp connection. If failover is not enabled, \tcpls would opportunistically try to reestablish the connection. However, if failover is not enabled and records were in flight while receiving an illegitimate \rst or \fin (e.g., sent by a middlebox), \tcpls may suffer from a decryption error, and report a critical error to the application.
