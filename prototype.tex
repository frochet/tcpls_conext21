% !TEX root = ./paper.tex
\label{sec:content}

In this section, we describe our \tcpls implementation.  In a nutshell, our implementation offers the following benefits:
($i$) The support of parallel streams and multiplexing over \tcp connections
  with different cryptographic context.
($ii$) An experimental API that wraps \tls and \tcp and enables applications to
    handle multihoming, multipathing, and various transport layer mechanisms.
($iii$) An improved \tcp extensibility mechanism that sends \tcp options
   through the secure \tcpls channel (as described in
   Sec.~\ref{sec:background-design}). We currently support Linux's \tcp User Timeout
   option. Supporting another \tcp option is only a matter of extending the
   sender's API and processing the option on the receiver side. \tcpls's
   internal machinery can already send any \tcp option during (server-side) or
   after (client-side) the handshake.
($iv$) Different multipath modes for the \tcpls streams: bandwidth aggregation or
none.
($v$) The ability for the server to send eBPF bytecode over the secure
  channel to upgrade the client's \tcp congestion control scheme or
  tune other \tcp mechanisms~\cite{brakmo2017tcp, tran2019beyond}.
  Variable-length options (e.g., eBPF bytecode) can be sent within streams to
  take advantage of bandwidth aggregation or Failover if those features are
  used.
($vi$) Different Connection Migration modes: Failover and Application-level
Connection Migration.


\fr{I don't want to give the impression that everything works like a charm -- I
would need 1 more year to have something production ready}
We stress that all of these features have been tested but this prototype is a
research-level implementation. The implementation can
showcase those features but is however not yet ready for production, as many
bugs likely remain despite our unit tests and integration tests. Portability was
neither part of our goals, but might be necessary for a production ready \tcpls
library.  \subsection{The \tcpls API}

The API that applications use to interact with a protocol plays an important
role in enabling them to leverage all the protocol features. The most
popular API to interact with the transport layer remains the BSD socket
API. Researchers and the IETF have explored new ways to expose a transport API~\cite{draft-ietf-taps-arch,hruby2014sockets,rfc6458,hesmans2016enhanced,schmidt2013socket}.

In this spirit, application-level developers would only be required to
configure a \tcpls context and register function callbacks.
%We design \tcpls such
%that the application-level developers can ignore any notion of Network IPC as
%defined by, for example, the POSIX API, the Berkeley socket API or Winsock,
%facilitating application-level development by offering a more concrete
%session-level interface based on asynchronous network events.
%The overall idea is to offer to application developers the opportunity to tune
%the transport protocol for a better usage of the network from their own
%application protocol, which might depend on its distinguishing
%features.
%\todo{we need to explain the mpjoin}
To illustrate \tcpls API's flexibility, we consider a simple
use case inspired by Happy Eyeballs~\cite{rfc8305}. This technique is
used by web browsers when interacting with dual-stack servers. They
try to establish \tcp connections using IPv4 and IPv6 and prefer the
one that offers the lowest latency. This avoids problems when an address
family is broken on a path but not the other and sometimes results in
lower latency~\cite{bajpai2019longitudinal}.

\begin{figure}[!t]
  \resizebox{0.49\textwidth}{!}{%
\begin{tikzpicture}
   \colorlet{lightgray}{black!20}
   \tikzstyle{arrow} = [thick,->,>=stealth]
   \tikzset{state/.style={rectangle, dashed, draw, fill=white} }
   \node[black, fill=white] at (0.5,10) {Sender};
   \node[black, fill=white] at (4,10) {Receiver};
   \draw[very thick,->] (0.5,9.5) -- (0.5,-1.2);
   \draw[very thick,->] (4,9.5) -- (4,-1.2);
   \node at (-1,9) {tcpls\_new()};
   \node at (5, 9) {listen()};
   \node[align=left, fill=white] at (-0.8,7.8) {tcpls\_add\_v4(addr,
     primary)\\*tcpls\_add\_v6(addr6)};
   \node[fill=white, align=left] at (-0.4,6.5) {[ if (tcpls\_connect(addr,
     NULL)<0)*\\
     \indent~~tcpls\_connect(addr6, timeout)*]};
   \draw[black, thick, <->] (0.5,5.8) -- (4,5.8) node [midway, fill=white] {\tcp Handshake};
   \node[fill=white] at (0,5) (Callback) {Callback ev.};
   \node at (1,4.8) (here) {};
   \draw [->] (Callback) to[out=-80, in=-90,looseness=1.3] (here)
   to[out=90,in=80,looseness=1.5] (Callback);
   \node at (5, 5.8) {accept()};
   \node[align=right] at (5, 5) {tcpls\_new()\\tcpls\_accept()};
   \node at (-1,4.1) {tcpls\_handshake()};
   \node[fill=white] at (4.6,4.1) {tcpls\_handshake()};
   \draw[black, thick, <->] (0.5,3.6) -- (4,3.6) node [midway, fill=white] {\tcpls Handshake};
   \node[fill=white] at (0,3) (CB2) {Callback ev.};
   \node at (1,2.8) (here2) {};
   \draw [->] (CB2) to[out=-80, in=-90,looseness=1.3] (here2)
   to[out=90,in=80,looseness=1.5] (CB2);
   \node[fill=white] at (4.5,3) (CB3) {Callback ev.};
   \node at (5.5,2.8) (here3) {};
   \draw [->] (CB3) to[out=-80, in=-90,looseness=1.3] (here3)
   to[out=90,in=80,looseness=1.5] (CB3);
   \node[fill=white, align=left] at (-1, 1.2)
   {[tcpls\_handshake(addr6)*\\tcpls\_send()*\\tcpls\_stream\_new()*\\tcpls\_streams\_attach()*\\tcpls\_send\_tcpoption()*]};
   \draw[black, thick, <->] (0.5,-0.5) -- (4,-0.5) node [midway, fill=white,
   above, text width=2.4cm]
   {\{\tcpls Data\} \{APPDATA\}};
   \node[fill=white] at (4.7,-0.85) {tcpls\_receive()};
\end{tikzpicture}
}
\caption{API Workflow example. * means optional call, [ ] means optional call flow, and \{ \} means encrypted.}
  \label{fig:api}
\end{figure}

Fig.~\ref{fig:api} shows an example of our current API workflow. The API can
handle explicit multipath techniques such as Happy Eyeball by chaining
\texttt{tcpls\_connect()} with an appropriate timeout of 50ms, as shown in the
Figure. \tcpls lets the application explicitly choose the multipath mesh by
calling several times \texttt{tcpls\_connect(src, dest,timeout)};. The
application may configure callbacks to connection events that would occur within
\tcpls, such as a connection establishment, a stream attachment, a multipath
join, the reception of a \tcp option to tune \tcp, and more. When multiple
streams are attached to multiple \tcp connections, the application may configure
various \tcpls behaviours. Among them, we support HOL-blocking avoidance,
aggregation of bandwidth with multipathing, connection failover, and connection
migration. Note that, HOL-blocking avoidance is incompatible with the
aggregation of bandwidth with multipathing (the application can do either one
but not both at the same time).



%Note, those features are not stable yet, and many bugs remain to be fixed.

\subsection{Multipathing}

\subsubsection{Data Aggregation}
The application can connect and join multiple \tcp connection to
the same \tcpls session. As soon as one of the peers attaches streams to
different \tcp connections of the session, and enables the aggregation mode,
\tcpls adds a sequence number encrypted in the \tls record payload. This
sequence number is used to reorder the received records after decryption. Our
current state of implementation supports one global ordering, but
we envision for the \tcpls protocol to have streams potentially detached from
the global orderings. For example, an HTTP application may want to use an
aggregation mode for 2 streams over 2 \tcp connections downloading a video
content for the video playback engine, but the other streams used by the HTTP
client do not necessarly need to be part of the multipath bandwidth aggregation.

\subsubsection{Failover}\label{failover}
describing Failover

\subsubsection{Application-level Connection Migration}
\label{sec:connmigr}

Given the availability of multiple IP paths, connection migration might be a
powerful tool to improve the application connection's reliability.  We implement Connection migration and Failover as two distinct measures to handle
two different inquiries: ($i$) The application expects to take advantage of multiple IP paths. ($ii$) The application expects to be resilient to a network outage. In the first case, we implement connection migration and multipathing from a protocol viewpoint, as the same exchange of messages and API calls from \tcpls. It is left for the application to decide and program
through the API calls whether it wants to move all the traffic from one path to
another or split the traffic among the available paths according to any
scheduling policy. The second inquiry focuses on simply configuring \tcpls to automatically move the traffic to another available IP-level path if a network outage is detected.
%The current implementation supports surviving abrupt reset of the connection,
%yet we may also want to
%monitor the connection and switch to another one if the path quality is low.


\subsection{0-RTT Connections}
